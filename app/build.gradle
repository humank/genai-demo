plugins {
    id 'java'
    id 'org.springframework.boot' version '3.4.5'
    id 'io.spring.dependency-management' version '1.1.5'
    id 'io.qameta.allure' version '2.11.2' // Allure 插件
    id 'com.diffplug.spotless' version '6.25.0' // 代碼格式化插件
}

group = 'solid.humank'
version = '0.0.1-SNAPSHOT'

java {
    sourceCompatibility = '21'
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

// Allure 配置
allure {
    version = '2.22.1'
    useJUnit5 {
        version = '2.22.1'
    }
}

// 定義 Allure 結果目錄
def allureResultsDir = layout.buildDirectory.dir('allure-results').get().asFile.absolutePath

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    implementation 'org.flywaydb:flyway-core'
    implementation 'com.h2database:h2'
    
    // OpenAPI 3 (Swagger) 支援
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.2.0'
    
    // ArchUnit for architecture testing
    testImplementation 'com.tngtech.archunit:archunit-junit5:1.2.0'
    
    // Cucumber for BDD testing
    testImplementation 'io.cucumber:cucumber-java:7.15.0'
    testImplementation 'io.cucumber:cucumber-junit-platform-engine:7.15.0'
    testImplementation 'io.cucumber:cucumber-picocontainer:7.15.0'
    
    // JUnit 5
    testImplementation(platform('org.junit:junit-bom:5.10.2'))
    testImplementation('org.junit.jupiter:junit-jupiter')
    testImplementation('org.junit.platform:junit-platform-suite')
    
    // 確保 JUnit Platform 相關依賴版本一致
    constraints {
        testImplementation('org.junit.platform:junit-platform-commons:1.10.2')
        testImplementation('org.junit.platform:junit-platform-engine:1.10.2')
    }
    
    // Mockito
    testImplementation 'org.mockito:mockito-core:5.8.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.8.0'
    testImplementation 'org.mockito:mockito-inline:5.2.0'
    
    // Spring Test
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    
    // Allure 依賴
    testImplementation 'io.qameta.allure:allure-junit5:2.22.1'
    testImplementation 'io.qameta.allure:allure-cucumber7-jvm:2.22.1'
    testImplementation 'io.qameta.allure:allure-java-commons:2.22.1'
    
    compileOnly 'org.projectlombok:lombok:1.18.38'
    annotationProcessor 'org.projectlombok:lombok:1.18.38'
    testCompileOnly 'org.projectlombok:lombok:1.18.38'
    testAnnotationProcessor 'org.projectlombok:lombok:1.18.38'
}

// 配置 Java 編譯和執行任務啟用預覽功能
tasks.withType(JavaCompile).configureEach {
    options.compilerArgs += '--enable-preview'
    options.release = 21
}

tasks.withType(Test).configureEach {
    jvmArgs += '--enable-preview'
}

tasks.withType(JavaExec).configureEach {
    jvmArgs += '--enable-preview'
}

// 讓編譯任務依賴於代碼格式化
tasks.named('compileJava') {
    dependsOn 'spotlessApply'
}

// 標準單元測試任務
tasks.named('test') {
    useJUnitPlatform {
        // 包含所有測試，包括 Cucumber 測試
        includeTags 'cucumber', 'architecture', 'unit'
    }
    
    // Allure 配置
    systemProperty 'allure.results.directory', "${buildDir}/allure-results"
    systemProperty 'allure.epic', 'DDD架構測試'
    systemProperty 'allure.feature', 'JUnit測試'
    
    testLogging {
        events "passed", "skipped", "failed"
        showStandardStreams = true
        exceptionFormat = 'full'
    }
    
    systemProperty 'junit.jupiter.extensions.autodetection.enabled', 'true'
    systemProperty 'junit.platform.output.capture.stdout', 'true'
    systemProperty 'junit.platform.output.capture.stderr', 'true'
    
    // 確保 Cucumber 測試被包含
    include '**/*Test.java'
    include '**/*Tests.java'
    include '**/CucumberTestRunner.java'
}

// Cucumber 測試任務
tasks.register('cucumber', JavaExec) {
    dependsOn assemble, testClasses
    getMainClass().set("io.cucumber.core.cli.Main")
    classpath = configurations.testRuntimeClasspath + sourceSets.main.output + sourceSets.test.output
    args = [
        '--plugin', 'pretty',
        '--plugin', 'html:build/reports/cucumber/cucumber-report.html',
        '--plugin', 'json:build/reports/cucumber/cucumber-report.json',
        '--plugin', 'io.qameta.allure.cucumber7jvm.AllureCucumber7Jvm',
        '--glue', 'solid.humank.genaidemo.bdd',
        'src/test/resources/features'
    ]
    
    systemProperty 'allure.results.directory', allureResultsDir
    systemProperty 'allure.epic', 'BDD功能測試'
    systemProperty 'allure.feature', 'Cucumber測試'
    
    // 確保 Cucumber 測試結果被正確處理
    finalizedBy 'prepareAllureResults'
}

// DDD 架構測試任務
tasks.register('testArchitecture', Test) {
    description = '執行 DDD 與六邊形架構的規範測試'
    group = 'verification'
    
    useJUnitPlatform()
    include '**/architecture/**'
    
    reports {
        html.required = true
        junitXml.required = true
    }
    
    reports.html.outputLocation.set(file("${buildDir}/reports/tests/architecture"))
    
    testLogging {
        events "passed", "skipped", "failed"
        showStandardStreams = true
        exceptionFormat = 'full'
    }
    
    systemProperty 'allure.results.directory', allureResultsDir
    systemProperty 'allure.epic', '架構合規性'
    systemProperty 'allure.feature', '架構規範測試'
}

// 運行所有測試並生成報告
tasks.register('runAllTests') {
    dependsOn test, testArchitecture, cucumber, prepareAllureResults
    description = '運行所有測試並生成 Allure 報告'
    group = 'verification'
    
    doLast {
        println "所有測試已完成，包括單元測試、架構測試和 Cucumber 測試"
    }
    
    finalizedBy 'allureReport'
}

// 運行所有測試並啟動報告服務器
tasks.register('runAllTestsWithReport') {
    dependsOn 'runAllTests'
    description = '運行所有測試並啟動 Allure 報告服務器'
    group = 'verification'
    
    finalizedBy 'allureServe'
}

// 清理 Allure 結果目錄
tasks.register('cleanAllureResults', Delete) {
    delete(allureResultsDir)
    description = '清理 Allure 結果目錄'
    group = 'build'
}

tasks.named('clean') {
    dependsOn 'cleanAllureResults'
}

// 手動處理 Allure 報告生成，避免使用內建任務
tasks.register('prepareAllureResults') {
    description = '準備 Allure 報告數據'
    group = 'reporting'
    
    doLast {
        // 確保 allure-results 目錄存在
        mkdir "${buildDir}/allure-results"
        
        // 複製 Cucumber 測試結果
        copy {
            from "${buildDir}/reports/cucumber"
            into "${buildDir}/allure-results"
            include "**/*.json"
        }
        
        // 複製 JUnit 測試結果
        copy {
            from "${buildDir}/test-results/test"
            into "${buildDir}/allure-results"
            include "**/*.xml"
        }
        
        // 創建 executor.json 文件
        def executorFile = new File("${buildDir}/allure-results/executor.json")
        executorFile.text = """{
            "name": "Gradle",
            "type": "gradle",
            "buildName": "GenAI Demo Project",
            "reportName": "DDD 架構測試報告"
        }"""
        
        println "Allure 報告數據準備完成，結果目錄: ${buildDir}/allure-results"
    }
}

// 覆蓋 allureReport 任務
tasks.named('allureReport') {
    dependsOn 'prepareAllureResults'
}

// Spotless 配置 - 代碼格式化和 import 清理
spotless {
    java {
        // 指定要處理的文件
        target 'src/**/*.java'
        
        // 移除未使用的 imports
        removeUnusedImports()
        
        // 整理 imports 順序
        importOrder('java', 'javax', 'org', 'com', '')
        
        // 使用 Google Java Format
        googleJavaFormat('1.19.2').aosp().reflowLongStrings()
        
        // 或者使用 Eclipse formatter（註釋掉上面的 googleJavaFormat 行）
        // eclipse().configFile('eclipse-formatter.xml')
        
        // 確保文件以換行符結尾
        endWithNewline()
        
        // 移除行尾空白
        trimTrailingWhitespace()
    }
    
    // Markdown 格式化配置
    format 'markdown', {
        target '**/*.md'
        
        // 使用 Prettier 格式化 Markdown
        prettier(['prettier': '2.8.8', 'prettier-plugin-organize-imports': '3.2.2'])
            .config([
                'parser': 'markdown',
                'printWidth': 80,
                'tabWidth': 2,
                'useTabs': false,
                'semi': false,
                'singleQuote': true,
                'quoteProps': 'as-needed',
                'trailingComma': 'es5',
                'bracketSpacing': true,
                'proseWrap': 'preserve'
            ])
        
        // 確保文件以換行符結尾
        endWithNewline()
        
        // 移除行尾空白
        trimTrailingWhitespace()
    }
}

// 自定義任務：只清理 imports（不格式化其他內容）
tasks.register('cleanImports') {
    description = '只清理 Java 代碼中未使用的 imports，不進行其他格式化'
    group = 'formatting'
    
    doLast {
        // 使用 Spotless 的 removeUnusedImports 功能
        exec {
            commandLine 'sh', '-c', """
                find src -name "*.java" -exec sed -i '' '/^import.*unused/d' {} \\;
            """
        }
        println "未使用的 imports 已清理完成！"
    }
}

// Markdown 格式化和語法修正任務
tasks.register('formatMarkdown') {
    description = '格式化和修正 Markdown 文件語法結構'
    group = 'formatting'
    
    doLast {
        // 找到所有 Markdown 文件
        def markdownFiles = fileTree(dir: '.', include: '**/*.md', exclude: ['**/node_modules/**', '**/build/**', '**/.git/**']).files
        
        println "正在處理 ${markdownFiles.size()} 個 Markdown 文件..."
        
        markdownFiles.each { file ->
            def content = file.text
            def originalContent = content
            
            // 修正標題格式（確保 # 後面有空格）
            content = content.replaceAll(/^(#{1,6})([^\s#])/, '$1 $2')
            
            // 修正列表格式（確保 - 或 * 後面有空格）
            content = content.replaceAll(/^(\s*[-*])([^\s])/, '$1 $2')
            
            // 修正數字列表格式
            content = content.replaceAll(/^(\s*\d+\.)([^\s])/, '$1 $2')
            
            // 修正代碼塊格式（確保前後有空行）
            content = content.replaceAll(/([^\n])\n```/, '$1\n\n```')
            content = content.replaceAll(/```\n([^\n])/, '```\n\n$1')
            
            // 修正鏈接格式
            content = content.replaceAll(/\[([^\]]+)\]\s*\(([^)]+)\)/, '[$1]($2)')
            
            // 移除多餘的空行（超過兩個連續空行）
            content = content.replaceAll(/\n{3,}/, '\n\n')
            
            // 確保文件以單個換行符結尾
            content = content.replaceAll(/\n*$/, '\n')
            
            if (content != originalContent) {
                file.text = content
                println "已修正: ${file.name}"
            }
        }
        
        println "Markdown 文件格式化完成！"
    }
}

// Markdown 語法檢查任務
tasks.register('lintMarkdown') {
    description = '檢查 Markdown 文件語法'
    group = 'verification'
    
    doLast {
        def markdownFiles = fileTree(dir: '.', include: '**/*.md', exclude: ['**/node_modules/**', '**/build/**', '**/.git/**']).files
        def issues = []
        
        markdownFiles.each { file ->
            def content = file.text
            def lines = content.split('\n')
            
            lines.eachWithIndex { line, index ->
                def lineNumber = index + 1
                
                // 檢查標題格式
                if (line.matches(/^#{1,6}[^\s#]/)) {
                    issues.add("${file.name}:${lineNumber} - 標題後缺少空格")
                }
                
                // 檢查列表格式
                if (line.matches(/^\s*[-*][^\s]/)) {
                    issues.add("${file.name}:${lineNumber} - 列表項後缺少空格")
                }
                
                // 檢查數字列表格式
                if (line.matches(/^\s*\d+\.[^\s]/)) {
                    issues.add("${file.name}:${lineNumber} - 數字列表後缺少空格")
                }
                
                // 檢查行尾空白
                if (line.endsWith(' ') || line.endsWith('\t')) {
                    issues.add("${file.name}:${lineNumber} - 行尾有多餘空白")
                }
            }
        }
        
        if (issues.isEmpty()) {
            println "✅ 所有 Markdown 文件語法檢查通過！"
        } else {
            println "❌ 發現 ${issues.size()} 個 Markdown 語法問題："
            issues.each { println "  $it" }
            throw new GradleException("Markdown 語法檢查失敗")
        }
    }
}
// OpenAPI 文檔生成任務
tasks.register('generateApiDocs', Test) {
    description = '生成 OpenAPI 規範檔案 (JSON 和 YAML 格式)'
    group = 'documentation'
    
    // 任務依賴
    dependsOn assemble, testClasses
    
    // 配置 JUnit Platform
    useJUnitPlatform()
    include '**/OpenApiDocumentationTest.class'
    
    // 確保 docs/api 目錄存在
    doFirst {
        println '========================================='
        println '🚀 正在生成 OpenAPI 文檔...'
        println '========================================='
        
        // 創建輸出目錄
        def docsDir = file('docs/api')
        if (!docsDir.exists()) {
            docsDir.mkdirs()
            println "✅ 已創建目錄: ${docsDir.absolutePath}"
        }
    }
    
    // 測試執行配置
    testLogging {
        events "passed", "skipped", "failed"
        showStandardStreams = true
        exceptionFormat = 'full'
    }
    
    // 系統屬性配置
    systemProperty 'spring.profiles.active', 'test'
    systemProperty 'spring.test.context.cache.maxSize', '1'
    
    // 任務完成後的提示訊息
    doLast {
        println '========================================='
        println '✅ OpenAPI 文檔生成完成！'
        println '========================================='
        println '📁 檔案位置: docs/api/'
        println '📄 JSON 檔案: docs/api/openapi.json'
        println '📄 YAML 檔案: docs/api/openapi.yaml'
        println ''
        println '🌐 Swagger UI 訪問地址:'
        println '   http://localhost:8080/swagger-ui.html'
        println ''
        println '📖 API 文檔訪問地址:'
        println '   http://localhost:8080/v3/api-docs (JSON)'
        println '   http://localhost:8080/v3/api-docs.yaml (YAML)'
        println '========================================='
    }
    
    // 錯誤處理
    onlyIf {
        def testClass = file('src/test/java/solid/humank/genaidemo/infrastructure/OpenApiDocumentationTest.java')
        if (!testClass.exists()) {
            println "❌ 錯誤: 找不到 OpenApiDocumentationTest.java"
            println "   請確保測試類別存在於: ${testClass.absolutePath}"
            return false
        }
        return true
    }
}

// 文檔相關任務組
tasks.register('generateAllDocs') {
    description = '生成所有專案文檔 (API 文檔、架構圖等)'
    group = 'documentation'
    
    dependsOn generateApiDocs
    
    doFirst {
        println '🔄 開始生成所有專案文檔...'
    }
    
    doLast {
        println '✅ 所有文檔生成完成！'
        println ''
        println '📚 可用文檔:'
        println '   • API 文檔: docs/api/'
        println '   • 架構文檔: docs/'
        println '   • UML 圖表: docs/uml/'
        println ''
    }
}

// 驗證 API 文檔任務
tasks.register('validateApiDocs') {
    description = '驗證生成的 OpenAPI 文檔格式正確性'
    group = 'verification'
    
    dependsOn generateApiDocs
    
    doLast {
        def jsonFile = file('docs/api/openapi.json')
        def yamlFile = file('docs/api/openapi.yaml')
        
        println '🔍 驗證 API 文檔...'
        
        if (jsonFile.exists()) {
            try {
                // 簡單的 JSON 格式驗證
                def jsonContent = jsonFile.text
                if (jsonContent.contains('"openapi"') && jsonContent.contains('"info"')) {
                    println "✅ JSON 文檔格式正確: ${jsonFile.name}"
                } else {
                    throw new GradleException("❌ JSON 文檔格式不正確")
                }
            } catch (Exception e) {
                throw new GradleException("❌ JSON 文檔驗證失敗: ${e.message}")
            }
        } else {
            throw new GradleException("❌ 找不到 JSON 文檔: ${jsonFile.absolutePath}")
        }
        
        if (yamlFile.exists()) {
            def yamlContent = yamlFile.text
            if (yamlContent.contains('openapi:') && yamlContent.contains('info:')) {
                println "✅ YAML 文檔格式正確: ${yamlFile.name}"
            } else {
                throw new GradleException("❌ YAML 文檔格式不正確")
            }
        } else {
            throw new GradleException("❌ 找不到 YAML 文檔: ${yamlFile.absolutePath}")
        }
        
        println '✅ API 文檔驗證通過！'
    }
}

// 整合到建構流程 - 可選擇性地在 build 時生成文檔
tasks.register('buildWithDocs') {
    description = '建構專案並生成 API 文檔'
    group = 'build'
    
    dependsOn build, generateApiDocs
    
    doLast {
        println '🎉 專案建構完成，包含 API 文檔生成！'
    }
}