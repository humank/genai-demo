# Design Guidelines\n\n## Tell, Don't Ask Principle\n\n### Origin and History\nThe \"Tell, Don't Ask\" principle was first proposed by Alec Sharp in 1997 and later popularized in \"The Pragmatic Programmer\" by Andy Hunt and Dave Thomas. This principle emphasizes that you should tell objects what to do, rather than asking about their state and then deciding what to do.\n\n### Core Concepts\n- Objects should be responsible for handling their internal state\n- Callers should not make decisions based on an object's internal state\n- Encapsulation is not just about hiding data, but also hiding behavior\n\n### Bad Design Example\n```java\n// Violates Tell, Don't Ask\nif (order.getStatus() == OrderStatus.PENDING) {\n    order.setStatus(OrderStatus.PROCESSING);\n    // Process order...\n}\n```\n\n### Good Design Example\n```java\n// Follows Tell, Don't Ask\norder.process();  // Let the order handle its own state transition\n```\n\n### Application in Our Project\n\n1. Order Processing\n```java\n// Good design: Directly tell the order to process itself\norder.process();\n\n// Bad design: Check state then decide what to do\nif (order.getStatus() == OrderStatus.CREATED) {\n    order.submit();\n}\n```\n\n2. Inventory Management\n```java\n// Good design: Let inventory handle reservation logic itself\nReservationId reservationId = inventory.reserve(orderId, quantity);\n\n// Bad design: Check inventory then decide what to do\nif (inventory.getAvailableQuantity() >= quantity) {\n    inventory.setAvailableQuantity(inventory.getAvailableQuantity() - quantity);\n    // Create reservation...\n}\n```\n\n3. Delivery Status Management\n```java\n// Good design: Let delivery object handle state transition\ndelivery.markAsDelivered();\n\n// Bad design: Externally check state and set\nif (delivery.getStatus() == DeliveryStatus.IN_TRANSIT) {\n    delivery.setStatus(DeliveryStatus.DELIVERED);\n    delivery.setUpdatedAt(LocalDateTime.now());\n}\n```\n\n## Other Important Design Considerations\n\n### 1. Single Responsibility Principle (SRP)\n- Each class should have a clear responsibility\n- There should be only one reason to change\n- Good practices in our project:\n  - `Order` aggregate root focuses on order lifecycle management\n  - `Inventory` aggregate root focuses on inventory management\n  - `Delivery` aggregate root focuses on delivery process\n\n### 2. Layered Architecture\n- Presentation Layer: Handle HTTP requests/responses\n- Application Layer: Coordinate different services, handle transactions\n- Domain Layer: Implement core business logic\n- Infrastructure Layer: Provide technical support\n- Practices in our project:\n  - Aggregate roots in domain layer (like `Order`, `Inventory`) don't depend on infrastructure\n  - Application services coordinate domain objects to complete use cases\n  - Infrastructure layer implements interfaces defined by domain layer\n\n### 3. Separation of Concerns\n- Separate business logic from technical details\n- Separate domain logic from infrastructure concerns\n- Practices in our project:\n  - Use `OrderProcessingSaga` to coordinate operations across aggregate roots\n  - Domain events are used to decouple different contexts\n\n### 4. Dependency Inversion Principle (DIP)\n- High-level modules should not depend on low-level modules\n- Abstractions should not depend on details\n- Practices in our project:\n  - Use `Repository` interfaces to isolate domain layer from persistence implementation\n  - Use `DomainEvent` interface instead of concrete event classes\n\n### 5. Encapsulation\n- Hide implementation details\n- Provide meaningful interfaces\n- Control the scope of change impact\n- Practices in our project:\n  - `Money` value object encapsulates amount and currency, providing safe operation methods\n  - `OrderStatus` encapsulates state transition rules\n\n## Application in Domain-Driven Design (DDD)\n\n### Tell, Don't Ask and Bounded Contexts\n\nThe Tell, Don't Ask principle is particularly important when handling communication across bounded contexts:\n\n1. Event-Driven Communication\n   ```java\n   // Bad design\n   if (order.getStatus() == OrderStatus.CONFIRMED) {\n       Payment payment = new Payment(order.getId(), order.getTotalAmount());\n       paymentService.process(payment);\n   }\n\n   // Good design\n   order.confirm();  // Internally publishes OrderConfirmedEvent\n   // PaymentService subscribes and handles OrderConfirmedEvent\n   ```\n\n2. Bounded Context Autonomy\n   - Each context is responsible for its own decisions\n   - Notify other contexts through events\n   - Avoid direct queries between contexts\n   - Practices in our project:\n     - Order and Payment are independent contexts\n     - Communicate through `PaymentRequestedEvent`\n\n3. Anti-Corruption Layer Application\n   ```java\n   // Bad design: Directly expose external system details\n   ExternalPaymentSystem.PaymentStatus status = externalSystem.getPaymentStatus(id);\n   if (status == ExternalPaymentSystem.PaymentStatus.SUCCESS) {\n       // Processing logic\n   }\n\n   // Good design: Use anti-corruption layer to encapsulate external system\n   paymentAntiCorruptionLayer.processPayment(payment);\n   ```\n\n### DDD Tactical Pattern Application in Our Project\n\n#### 1. Aggregate Roots\n- Maintain their own business rules and invariants\n- Practices in our project:\n  - `Order` aggregate root ensures correct order state transitions\n  - `Inventory` aggregate root ensures inventory quantity consistency\n  - `Delivery` aggregate root manages delivery state transitions\n\n#### 2. Value Objects\n- Describe concepts in the domain without identity\n- Immutability ensures thread safety\n- Practices in our project:\n  - `Money` value object encapsulates amount and currency\n  - `OrderId`, `CustomerId` and other identifiers\n  - `OrderStatus`, `DeliveryStatus` and other status enums\n\n#### 3. Domain Events\n- Express important events that occur in the domain\n- Decouple different bounded contexts\n- Practices in our project:\n  - `OrderCreatedEvent`\n  - `OrderItemAddedEvent`\n  - `PaymentRequestedEvent`\n\n#### 4. Domain Services\n- Handle business logic that spans aggregate roots\n- Stateless\n- Practices in our project:\n  - `DomainEventPublisherService` handles event publishing\n\n#### 5. Specification Pattern\n- Encapsulate complex business rules\n- Composable conditional expressions\n- Practices in our project:\n  - `Specification` interface and its implementations\n  - `AndSpecification`, `OrSpecification` and other composite specifications\n\n## Defensive Programming Practices\n\nDefensive programming practices in our project:\n\n### 1. Precondition Checks\n```java\n// Parameter validation in Order aggregate root\npublic Order(OrderId orderId, CustomerId customerId, String shippingAddress) {\n    Preconditions.requireNonNull(orderId, \"Order ID cannot be null\");\n    Preconditions.requireNonNull(customerId, \"Customer ID cannot be null\");\n    Preconditions.requireNonEmpty(shippingAddress, \"Shipping address cannot be empty\");\n    // ...\n}\n```\n\n### 2. State Transition Protection\n```java\n// Order state transition protection\npublic void confirm() {\n    // Check state transition\n    if (!status.canTransitionTo(OrderStatus.CONFIRMED)) {\n        throw new IllegalStateException(\"Cannot confirm an order in \" + status + \" state\");\n    }\n    // Update state\n    status = OrderStatus.CONFIRMED;\n    updatedAt = LocalDateTime.now();\n}\n```\n\n### 3. Immutable Value Objects\n```java\n// Immutable design of Money value object\n@ValueObject\npublic class Money {\n    private final BigDecimal amount;\n    private final Currency currency;\n    \n    // No setters, only operation methods that return new instances\n    public Money add(Money money) {\n        if (!this.currency.equals(money.currency)) {\n            throw new IllegalArgumentException(\"Cannot add money with different currencies\");\n        }\n        return new Money(this.amount.add(money.amount), this.currency);\n    }\n}\n```\n\n### 4. Business Rule Encapsulation\n```java\n// Business rules in Inventory aggregate root\npublic ReservationId reserve(UUID orderId, int quantity) {\n    if (quantity <= 0) {\n        throw new IllegalArgumentException(\"Reservation quantity must be greater than zero\");\n    }\n    \n    if (!isSufficient(quantity)) {\n        throw new IllegalStateException(\"Insufficient inventory, cannot reserve\");\n    }\n    \n    // Business logic...\n}\n```\n\n## Design Pattern Applications\n\nDesign patterns applied in our project:\n\n### 1. Factory Method Pattern\n```java\n// Factory methods in OrderId value object\npublic static OrderId generate() {\n    return new OrderId(UUID.randomUUID());\n}\n\npublic static OrderId of(String id) {\n    return new OrderId(UUID.fromString(id));\n}\n```\n\n### 2. Strategy Pattern\nProvide interchangeable business rule validation strategies through different specification implementations.\n\n### 3. Observer Pattern\nImplement observer pattern through domain events, decoupling event publishers and subscribers.\n\n### 4. Command Pattern\nCommand and compensation operations in Saga pattern implement the command pattern concept.\n\n## Improvement Suggestions\n\nBased on project code analysis, here are some improvement suggestions:\n\n### 1. Enhanced Error Handling\n- Introduce dedicated business exception types, such as `InsufficientInventoryException`\n- Uniformly handle exceptions at the application layer, converting them to appropriate responses\n\n### 2. Enhanced Domain Event Mechanism\n- Consider using event sourcing pattern to record aggregate root state changes\n- Implement event persistence to support event replay\n\n### 3. Optimize Saga Implementation\n- Consider using state machine pattern to manage Saga state transitions\n- Enhance robustness of compensation logic\n\n### 4. Enhanced Test Coverage\n- Add unit tests for boundary conditions\n- Add tests for concurrent scenarios\n\n## Reference Resources\n\n1. \"The Pragmatic Programmer\" - Andy Hunt & Dave Thomas\n2. \"Refactoring\" - Martin Fowler\n3. \"Domain-Driven Design\" - Eric Evans\n4. \"Implementing Domain-Driven Design\" - Vaughn Vernon\n5. Tell, Don't Ask by Alec Sharp\n\n---\n\n**Document Version**: 1.0  \n**Last Updated**: September 28, 2025  \n**Maintained by**: Development Team"