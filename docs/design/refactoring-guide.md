# Refactoring Guide: Based on \"Refactoring: Improving the Design of Existing Code\"\n\nThis document is compiled from Martin Fowler's classic work \"Refactoring: Improving the Design of Existing Code\", providing an overview of code smells, refactoring techniques, and related design principles to help developers improve code quality.\n\n## Table of Contents\n\n- Code Smells\n- Refactoring Techniques\n- Design Principles\n- Refactoring Process and Best Practices\n\n## Code Smells\n\nCode smells are signs that code may have problems. They usually indicate that code needs refactoring.\n\n### Major Code Direction Issues\n\n- **Duplicated Code**\n  - Same or similar code segments appear in multiple places\n  - Violates DRY (Don't Repeat Yourself) principle\n  - Solutions: Extract Method, Pull Up Method, Form Template Method\n\n- **Long Method**\n  - Methods are too lengthy, difficult to understand and maintain\n  - Solutions: Extract Method, Replace Temp with Query, Introduce Parameter Object\n\n- **Large Class**\n  - A class takes on too many responsibilities, has too many fields and methods\n  - Solutions: Extract Class, Extract Subclass, Extract Interface\n\n- **Long Parameter List**\n  - Too many method parameters, making calls and understanding difficult\n  - Solutions: Introduce Parameter Object, Preserve Whole Object, Replace Parameter with Method\n\n- **Divergent Change**\n  - Whenever a certain change occurs, multiple parts of the same class need to be changed\n  - Solutions: Extract Class\n\n- **Shotgun Surgery**\n  - One change causes multiple different classes to need modification\n  - Solutions: Move Method, Move Field, Inline Class\n\n- **Feature Envy**\n  - A method is more interested in other classes than its own class\n  - Solutions: Move Method, Extract Method\n\n- **Data Clumps**\n  - Same combination of data items appears in multiple places\n  - Solutions: Extract Class, Introduce Parameter Object, Preserve Whole Object\n\n- **Primitive Obsession**\n  - Overuse of primitive types instead of small objects to represent simple concepts\n  - Solutions: Replace Data Value with Object, Replace Type Code with Class, Replace Type Code with Subclasses\n\n- **Switch Statements**\n  - Same switch statement scattered in multiple places\n  - Solutions: Replace Conditional with Polymorphism, Replace Type Code with Subclasses, Replace Type Code with State/Strategy\n\n- **Parallel Inheritance Hierarchies**\n  - Whenever adding a subclass to one inheritance hierarchy, must also add corresponding subclass to another hierarchy\n  - Solutions: Move Method, Move Field\n\n- **Lazy Class**\n  - Class usefulness is insufficient to justify its existence\n  - Solutions: Inline Class, Collapse Hierarchy\n\n- **Speculative Generality**\n  - Abstractions and flexibility designed prematurely for future possible needs\n  - Solutions: Collapse Hierarchy, Inline Class, Remove Parameter, Rename Method\n\n### Specific Code Issues\n\n- **Temporary Field**\n  - A field is meaningful only in specific situations\n  - Solutions: Extract Class, Introduce Special Case\n\n- **Message Chains**\n  - Client requests an object, then another object, forming a chain of associations\n  - Solutions: Hide Delegate, Extract Method, Move Method\n\n- **Middle Man**\n  - A class's main function is delegating to other classes\n  - Solutions: Remove Middle Man, Inline Method, Replace Delegation with Inheritance\n\n- **Inappropriate Intimacy**\n  - One class knows too much about another class's internal details\n  - Solutions: Move Method, Move Field, Change Bidirectional Association to Unidirectional, Extract Class, Hide Delegate\n\n- **Alternative Classes with Different Interfaces**\n  - Different classes have methods that perform similar functions but with different signatures\n  - Solutions: Rename Method, Move Method, Extract Superclass\n\n- **Incomplete Library Class**\n  - Library class doesn't provide needed functionality\n  - Solutions: Introduce Foreign Method, Introduce Local Extension\n\n- **Data Class**\n  - Class containing only fields and access methods, no behavior\n  - Solutions: Move Method, Encapsulate Field, Encapsulate Collection\n\n- **Refused Bequest**\n  - Subclass doesn't need or want to inherit some methods or properties from parent class\n  - Solutions: Replace Inheritance with Delegation, Extract Superclass, Extract Interface\n\n- **Comments**\n  - Too many comments may indicate insufficient code design clarity\n  - Solutions: Extract Method, Rename Method, Introduce Assertion\n\n## Refactoring Techniques\n\n### Composing Methods\n\n- **Extract Method**\n  - Extract code fragments into reusable functions\n  - Improve readability and avoid duplication\n\n- **Inline Method**\n  - Replace function calls with actual function content\n  - Use when function body is clearer than function name\n\n- **Extract Variable**\n  - Store expression results in variables\n  - Make complex expressions easier to understand\n\n- **Inline Temp**\n  - Replace temporary variables with their values\n  - Simplify unnecessary indirection\n\n- **Replace Temp with Query**\n  - Extract expressions into separate methods\n  - Make code more readable and reusable\n\n- **Split Temporary Variable**\n  - Create independent variables for each assignment\n  - Avoid variables taking on multiple responsibilities\n\n- **Remove Assignments to Parameters**\n  - Use local variables instead of modifying parameters\n  - Avoid side effects and confusion\n\n- **Replace Method with Method Object**\n  - Transform complex methods into new classes\n  - Facilitate decomposition of long methods\n\n- **Substitute Algorithm**\n  - Replace existing implementation with clearer algorithm\n  - Improve readability and performance\n\n### Moving Features\n\n- **Move Method**\n  - Move method to more appropriate class\n  - Improve cohesion and reduce coupling\n\n- **Move Field**\n  - Move field to more appropriate class\n  - Improve data and behavior configuration\n\n- **Extract Class**\n  - Separate responsibilities from one class\n  - Create two more cohesive classes\n\n- **Inline Class**\n  - Merge class content into another class\n  - When class has lost its reason for existence\n\n- **Hide Delegate**\n  - Create methods in delegate class\n  - Reduce client knowledge of delegation relationships\n\n- **Remove Middle Man**\n  - Interact directly with real objects\n  - When delegation relationship is overly simple\n\n- **Introduce Foreign Method**\n  - Add function in client class and pass service class instance\n  - When service class cannot be modified\n\n- **Introduce Local Extension**\n  - Create subclass or wrapper class of service class\n  - Add needed functionality\n\n### Organizing Data\n\n- **Self Encapsulate Field**\n  - Access fields through accessor methods rather than directly\n  - Increase subclass flexibility\n\n- **Replace Data Value with Object**\n  - Transform simple data into objects\n  - Add behavior or more structure\n\n- **Change Value to Reference**\n  - Transform multiple copies of same object into references\n  - Ensure consistency\n\n- **Change Reference to Value**\n  - Transform reference objects into immutable value objects\n  - Simplify code and avoid side effects\n\n- **Replace Array with Object**\n  - Replace arrays of different element types with objects\n  - Improve code clarity\n\n- **Duplicate Observed Data**\n  - Separate domain data from UI objects\n  - Improve code structure and testability\n\n- **Change Unidirectional Association to Bidirectional**\n  - Add reverse references\n  - Facilitate bidirectional navigation\n\n- **Change Bidirectional Association to Unidirectional**\n  - Remove unnecessary association directions\n  - Reduce coupling\n\n- **Replace Magic Number with Symbolic Constant**\n  - Replace hard-coded values with named constants\n  - Improve readability and maintainability\n\n- **Encapsulate Field**\n  - Make public fields private and provide accessors\n  - Control access and add behavior\n\n- **Encapsulate Collection**\n  - Provide add/remove methods instead of directly returning collections\n  - Control collection modifications\n\n- **Replace Type Code with Class**\n  - Replace enums or constants with classes\n  - Increase type safety and extensibility\n\n- **Replace Type Code with Subclasses**\n  - Create subclasses for each type\n  - Utilize polymorphism\n\n- **Replace Type Code with State/Strategy**\n  - Move type-related behavior to state or strategy classes\n  - More flexible behavior changes\n\n- **Replace Subclass with Fields**\n  - Move subclass-specific behavior to parent class fields\n  - Simplify unnecessary inheritance\n\n### Simplifying Conditional Expressions\n\n- **Decompose Conditional**\n  - Extract complex conditions into named methods\n  - Make conditions easier to understand\n\n- **Consolidate Conditional Expression**\n  - Combine multiple checks with same results\n  - Highlight check intentions\n\n- **Consolidate Duplicate Conditional Fragments**\n  - Move duplicate code from conditional branches outside conditions\n  - Reduce duplication\n\n- **Remove Control Flag**\n  - Use break or return instead of control flags\n  - Simplify loop or conditional structures\n\n- **Replace Nested Conditional with Guard Clauses**\n  - Use early returns to handle special cases\n  - Reduce nesting and highlight main logic\n\n- **Replace Conditional with Polymorphism**\n  - Move conditional logic to class hierarchies\n  - Use polymorphism for dynamic behavior\n\n- **Introduce Null Object**\n  - Replace null checks with special objects\n  - Avoid null check proliferation\n\n- **Introduce Assertion**\n  - Add assertions to explain assumptions\n  - Clearly express code assumptions\n\n### Simplifying Method Calls\n\n- **Rename Method**\n  - Make method names clearly express their intent\n  - Improve self-documentation\n\n- **Add Parameter**\n  - Add parameters to method signature\n  - Provide more information\n\n- **Remove Parameter**\n  - Delete unused parameters\n  - Simplify method signature\n\n- **Separate Query from Modifier**\n  - Separate read and modify operations\n  - Improve safety\n\n- **Parameterize Method**\n  - Combine multiple similar methods into single parameterized method\n  - Reduce duplicate code\n\n- **Introduce Parameter Object**\n  - Organize multiple parameters into an object\n  - Simplify parameter lists\n\n- **Preserve Whole Object**\n  - Pass entire object instead of multiple separate properties\n  - Simplify parameter passing\n\n- **Replace Parameter with Explicit Methods**\n  - Create separate methods for different behaviors\n  - Simplify client code\n\n- **Introduce Named Parameter**\n  - Make parameter meanings more explicit\n  - Improve readability\n\n- **Hide Method**\n  - Make methods that don't need external calls private\n  - Reduce public interface\n\n- **Replace Constructor with Factory Method**\n  - Use factory methods to create objects\n  - Provide more flexibility\n\n- **Encapsulate Downcast**\n  - Move casting inside methods\n  - Return correct types from methods\n\n- **Replace Error Code with Exception**\n  - Use exceptions instead of return error codes\n  - Handle error situations more explicitly\n\n- **Replace Exception with Test**\n  - Use conditional tests instead of exceptions when possible\n  - Avoid exception handling performance overhead\n\n### Dealing with Generalization\n\n- **Pull Up Field**\n  - Move same fields to parent class\n  - Eliminate duplication\n\n- **Pull Up Method**\n  - Move same methods to parent class\n  - Eliminate duplication\n\n- **Pull Up Constructor Body**\n  - Move common parts of subclass constructors to parent class\n  - Reuse initialization code\n\n- **Push Down Method**\n  - Move methods to specific subclasses\n  - When methods are only relevant to certain subclasses\n\n- **Push Down Field**\n  - Move fields to specific subclasses\n  - When fields are only relevant to certain subclasses\n\n- **Extract Subclass**\n  - Create subclasses for special behaviors\n  - Separate special behaviors from main class\n\n- **Extract Superclass**\n  - Extract common features from classes to create parent class\n  - Reduce duplication\n\n- **Extract Interface**\n  - Extract common method signatures as interfaces\n  - Clarify class capabilities\n\n- **Collapse Hierarchy**\n  - Merge subclasses and parent classes\n  - When they don't differ much\n\n- **Form Template Method**\n  - Define algorithm skeleton in parent class, implement specific steps in subclasses\n  - Reuse algorithm structure\n\n- **Replace Inheritance with Delegation**\n  - Use composition instead of inheritance relationships\n  - Avoid problems caused by inappropriate inheritance\n\n- **Replace Delegation with Inheritance**\n  - Use inheritance when a class completely delegates to another class\n  - Simplify code\n\n## Design Principles\n\n### SOLID Principles\n\n- **Single Responsibility Principle (SRP)**\n  - A class should have only one reason to change\n  - Each class should be responsible for only one task\n\n- **Open-Closed Principle (OCP)**\n  - Open for extension, closed for modification\n  - New functionality should be implemented through extension, not modifying existing code\n\n- **Liskov Substitution Principle (LSP)**\n  - Subclasses should be able to replace their parent classes\n  - Ensure correct use of inheritance\n\n- **Interface Segregation Principle (ISP)**\n  - Clients should not be forced to depend on methods they don't use\n  - Interfaces should be small and focused\n\n- **Dependency Inversion Principle (DIP)**\n  - High-level modules should not depend on low-level modules; both should depend on abstractions\n  - Abstractions should not depend on details; details should depend on abstractions\n\n### Other Important Principles\n\n- **Law of Demeter/Principle of Least Knowledge**\n  - An object should know as little as possible about other objects\n  - Reduce coupling between objects\n\n- **Composition Over Inheritance**\n  - Prefer object composition over inheritance\n  - Improve flexibility and reduce coupling\n\n- **High Cohesion, Low Coupling**\n  - Related functionality should be concentrated in the same module\n  - Dependencies between different modules should be minimized\n\n- **DRY Principle (Don't Repeat Yourself)**\n  - Avoid duplicate code and knowledge\n  - Each piece of knowledge should have a clear representation in the system\n\n- **YAGNI Principle (You Aren't Gonna Need It)**\n  - Don't develop functionality for future possible needs\n  - Focus on current definite requirements\n\n- **Separation of Concerns**\n  - Different functions and responsibilities should be separated\n  - A component should only focus on its main responsibility\n\n## Refactoring Process and Best Practices\n\n### Refactoring Process\n\n- **Ensure Test Coverage**\n  - Ensure adequate testing before refactoring\n  - Run tests after each small refactoring step\n\n- **Small Steps Forward**\n  - Make small, safe changes\n  - Test frequently to ensure no errors are introduced\n\n- **Solve One Problem at a Time**\n  - Avoid multiple refactorings simultaneously\n  - Keep changes manageable\n\n- **Separate Refactoring from New Feature Development**\n  - Don't refactor while adding new features\n  - Clearly distinguish these two activities\n\n### When to Refactor\n\n- **When Adding Features**\n  - Make code easier to understand and modify\n  - Prepare for new functionality\n\n- **When Fixing Bugs**\n  - Improve code structure to make problems more obvious\n  - Prevent similar future problems\n\n- **During Code Reviews**\n  - Make improvements based on team feedback\n  - Unify code style and structure\n\n- **Regular Maintenance Activities**\n  - Dedicated refactoring periods\n  - Address technical debt\n\n### Implementation Considerations\n\n- **Team Collaboration**\n  - Discuss important refactorings with team members\n  - Share refactoring strategies and learning\n\n- **Documentation and Communication**\n  - Document reasons and methods for major refactorings\n  - Inform relevant team members\n\n- **Version Control**\n  - Commit small changes frequently\n  - Use meaningful commit messages\n\n- **Monitor Performance and Resource Usage**\n  - Ensure refactoring doesn't introduce performance issues\n  - Test performance under different scenarios\n\n## Summary\n\nRefactoring is an important practice in software development that helps us continuously improve code quality, making systems easier to understand, maintain, and adapt to changes. By identifying code smells, applying appropriate refactoring techniques, and following good design principles, we can create robust, flexible, and sustainable software systems.\n\nRefactoring is not a one-time activity but a continuous practice in the development process. Proper refactoring can reduce technical debt, improve team efficiency, and lay the foundation for rapid implementation of business requirements.\n\n---\n\n**Document Version**: 1.0  \n**Last Updated**: September 28, 2025  \n**Maintained by**: Development Team"