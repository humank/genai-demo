# Hexagonal Architecture\n\n## Overview\n\nThis document provides a comprehensive Hexagonal Architecture design guide, including architecture overview, Port-Adapter pattern, dependency inversion, and layered design implementation methods.\n\n## ðŸ”µ Hexagonal Architecture Overview\n\n### Core Concepts\n\nHexagonal Architecture (also known as Ports and Adapters Architecture) is a software architecture pattern designed to separate the application's core logic from external concerns.\n\n### Architectural Principles\n\n- **Single Responsibility Principle (SRP)**: Each class has only one reason to change\n- **Open-Closed Principle (OCP)**: Open for extension, closed for modification\n- **Dependency Inversion Principle (DIP)**: Depend on abstractions, not concrete implementations\n\n### Architectural Patterns\n\n- **Hexagonal Architecture**: Clear boundaries and dependency directions\n- **DDD Tactical Patterns**: Aggregate roots, entities, value objects\n- **Event-Driven Architecture**: Loosely coupled component communication\n\n### Code Structure\n\n```java\nsrc/main/java/\nâ”œâ”€â”€ domain/                    # Domain layer (core business logic)\nâ”‚   â”œâ”€â”€ model/                # Aggregate roots, entities, value objects\nâ”‚   â”‚   â”œâ”€â”€ Customer.java     # Aggregate root\nâ”‚   â”‚   â”œâ”€â”€ CustomerId.java   # Value object\nâ”‚   â”‚   â””â”€â”€ CustomerStatus.java\nâ”‚   â”œâ”€â”€ events/               # Domain events\nâ”‚   â”‚   â””â”€â”€ CustomerCreatedEvent.java\nâ”‚   â””â”€â”€ services/             # Domain services\nâ”‚       â””â”€â”€ CustomerValidationService.java\nâ”‚\nâ”œâ”€â”€ application/              # Application layer (use case coordination)\nâ”‚   â”œâ”€â”€ port/                # Port definitions (abstractions)\nâ”‚   â”‚   â”œâ”€â”€ in/              # Input ports (driving ports)\nâ”‚   â”‚   â”‚   â””â”€â”€ CustomerUseCase.java\nâ”‚   â”‚   â””â”€â”€ out/             # Output ports (driven ports)\nâ”‚   â”‚       â”œâ”€â”€ CustomerRepository.java\nâ”‚   â”‚       â””â”€â”€ EmailService.java\nâ”‚   â”œâ”€â”€ commands/            # Command handling\nâ”‚   â”‚   â””â”€â”€ CreateCustomerCommand.java\nâ”‚   â”œâ”€â”€ queries/             # Query handling\nâ”‚   â”‚   â””â”€â”€ GetCustomerQuery.java\nâ”‚   â””â”€â”€ services/            # Application services\nâ”‚       â””â”€â”€ CustomerApplicationService.java\nâ”‚\nâ””â”€â”€ infrastructure/          # Infrastructure layer (technical implementation)\n    â”œâ”€â”€ adapter/            # Adapter implementations\n    â”‚   â”œâ”€â”€ in/            # Input adapters\n    â”‚   â”‚   â”œâ”€â”€ web/       # Web controllers\n    â”‚   â”‚   â”‚   â””â”€â”€ CustomerController.java\n    â”‚   â”‚   â””â”€â”€ messaging/ # Message handlers\n    â”‚   â”‚       â””â”€â”€ CustomerEventHandler.java\n    â”‚   â””â”€â”€ out/           # Output adapters\n    â”‚       â”œâ”€â”€ persistence/ # Data persistence\n    â”‚       â”‚   â”œâ”€â”€ CustomerJpaRepository.java\n    â”‚       â”‚   â””â”€â”€ CustomerRepositoryAdapter.java\n    â”‚       â””â”€â”€ external/   # External services\n    â”‚           â””â”€â”€ EmailServiceAdapter.java\n    â”œâ”€â”€ configuration/      # Configuration\n    â”‚   â””â”€â”€ ApplicationConfiguration.java\n    â””â”€â”€ persistence/        # JPA entities\n        â””â”€â”€ CustomerEntity.java\n```\n\n## ðŸ”Œ Port-Adapter Pattern\n\n### Port Definitions\n\nPorts are contracts between the application core and the external world, defining the application's boundaries.\n\n#### Input Ports (Driving Ports)\n\nInput ports define the functionality provided by the application:\n\n```java\npublic interface CustomerUseCase {\n    CustomerResponse createCustomer(CreateCustomerCommand command);\n    CustomerResponse updateCustomer(UpdateCustomerCommand command);\n    CustomerResponse getCustomer(GetCustomerQuery query);\n    void deleteCustomer(DeleteCustomerCommand command);\n}\n```\n\n#### Output Ports (Driven Ports)\n\nOutput ports define the external services needed by the application:\n\n```java\n// Repository port\npublic interface CustomerRepository {\n    void save(Customer customer);\n    Optional<Customer> findById(CustomerId customerId);\n    Optional<Customer> findByEmail(Email email);\n    List<Customer> findByStatus(CustomerStatus status);\n    void delete(CustomerId customerId);\n}\n\n// External service port\npublic interface EmailService {\n    void sendWelcomeEmail(Email email, CustomerName name);\n    void sendPasswordResetEmail(Email email, String resetToken);\n    void sendAccountDeactivationEmail(Email email, CustomerName name);\n}\n\n// Event publishing port\npublic interface EventPublisher {\n    void publish(DomainEvent event);\n    void publishAll(List<DomainEvent> events);\n}\n```\n\n### Adapter Implementations\n\nAdapters implement the contracts defined by ports, connecting the application core with external technologies.\n\n#### Input Adapters\n\n##### Web Controller Adapter\n\n```java\n@RestController\n@RequestMapping(\"/api/v1/customers\")\npublic class CustomerController {\n    \n    private final CustomerUseCase customerUseCase;\n    \n    public CustomerController(CustomerUseCase customerUseCase) {\n        this.customerUseCase = customerUseCase;\n    }\n    \n    @PostMapping\n    public ResponseEntity<CustomerResponse> createCustomer(\n            @Valid @RequestBody CreateCustomerRequest request) {\n        \n        CreateCustomerCommand command = new CreateCustomerCommand(\n            request.name(),\n            request.email(),\n            request.phone()\n        );\n        \n        CustomerResponse response = customerUseCase.createCustomer(command);\n        return ResponseEntity.status(HttpStatus.CREATED).body(response);\n    }\n    \n    @GetMapping(\"/{customerId}\")\n    public ResponseEntity<CustomerResponse> getCustomer(\n            @PathVariable String customerId) {\n        \n        GetCustomerQuery query = new GetCustomerQuery(CustomerId.of(customerId));\n        CustomerResponse response = customerUseCase.getCustomer(query);\n        return ResponseEntity.ok(response);\n    }\n    \n    @PutMapping(\"/{customerId}\")\n    public ResponseEntity<CustomerResponse> updateCustomer(\n            @PathVariable String customerId,\n            @Valid @RequestBody UpdateCustomerRequest request) {\n        \n        UpdateCustomerCommand command = new UpdateCustomerCommand(\n            CustomerId.of(customerId),\n            request.name(),\n            request.email(),\n            request.phone()\n        );\n        \n        CustomerResponse response = customerUseCase.updateCustomer(command);\n        return ResponseEntity.ok(response);\n    }\n}\n```\n\n##### Message Handler Adapter\n\n```java\n@Component\npublic class CustomerEventMessageHandler {\n    \n    private final CustomerUseCase customerUseCase;\n    \n    public CustomerEventMessageHandler(CustomerUseCase customerUseCase) {\n        this.customerUseCase = customerUseCase;\n    }\n    \n    @EventListener\n    public void handleExternalCustomerUpdate(ExternalCustomerUpdateEvent event) {\n        UpdateCustomerCommand command = new UpdateCustomerCommand(\n            CustomerId.of(event.getCustomerId()),\n            new CustomerName(event.getName()),\n            new Email(event.getEmail()),\n            new Phone(event.getPhone())\n        );\n        \n        customerUseCase.updateCustomer(command);\n    }\n}\n```\n\n#### Output Adapters\n\n##### Database Adapter\n\n```java\n@Repository\npublic class CustomerRepositoryAdapter implements CustomerRepository {\n    \n    private final CustomerJpaRepository jpaRepository;\n    private final CustomerMapper customerMapper;\n    \n    public CustomerRepositoryAdapter(\n            CustomerJpaRepository jpaRepository,\n            CustomerMapper customerMapper) {\n        this.jpaRepository = jpaRepository;\n        this.customerMapper = customerMapper;\n    }\n    \n    @Override\n    public void save(Customer customer) {\n        CustomerEntity entity = customerMapper.toEntity(customer);\n        jpaRepository.save(entity);\n    }\n    \n    @Override\n    public Optional<Customer> findById(CustomerId customerId) {\n        return jpaRepository.findById(customerId.getValue())\n            .map(customerMapper::toDomain);\n    }\n    \n    @Override\n    public Optional<Customer> findByEmail(Email email) {\n        return jpaRepository.findByEmail(email.getValue())\n            .map(customerMapper::toDomain);\n    }\n    \n    @Override\n    public List<Customer> findByStatus(CustomerStatus status) {\n        return jpaRepository.findByStatus(status.name())\n            .stream()\n            .map(customerMapper::toDomain)\n            .collect(Collectors.toList());\n    }\n    \n    @Override\n    public void delete(CustomerId customerId) {\n        jpaRepository.deleteById(customerId.getValue());\n    }\n}\n```\n\n##### External Service Adapter\n\n```java\n@Component\npublic class EmailServiceAdapter implements EmailService {\n    \n    private final ExternalEmailClient emailClient;\n    private final EmailTemplateService templateService;\n    \n    public EmailServiceAdapter(\n            ExternalEmailClient emailClient,\n            EmailTemplateService templateService) {\n        this.emailClient = emailClient;\n        this.templateService = templateService;\n    }\n    \n    @Override\n    public void sendWelcomeEmail(Email email, CustomerName name) {\n        try {\n            EmailTemplate template = templateService.getWelcomeTemplate(name.getValue());\n            ExternalEmailRequest request = new ExternalEmailRequest(\n                email.getValue(),\n                template.getSubject(),\n                template.getBody()\n            );\n            \n            emailClient.sendEmail(request);\n            \n        } catch (ExternalServiceException e) {\n            throw new EmailDeliveryException(\"Failed to send welcome email\", e);\n        }\n    }\n    \n    @Override\n    public void sendPasswordResetEmail(Email email, String resetToken) {\n        try {\n            EmailTemplate template = templateService.getPasswordResetTemplate(resetToken);\n            ExternalEmailRequest request = new ExternalEmailRequest(\n                email.getValue(),\n                template.getSubject(),\n                template.getBody()\n            );\n            \n            emailClient.sendEmail(request);\n            \n        } catch (ExternalServiceException e) {\n            throw new EmailDeliveryException(\"Failed to send password reset email\", e);\n        }\n    }\n}\n```\n\n## ðŸ”„ Dependency Inversion\n\n### Dependency Inversion Principle\n\n1. **High-level modules should not depend on low-level modules. Both should depend on abstractions**\n2. **Abstractions should not depend on details. Details should depend on abstractions**\n\n### Manifestation in Hexagonal Architecture\n\n```mermaid\ngraph TD\n    A[Application Service<br/>Application Service] --> B[Port Interface<br/>Port Interface]\n    B <-- C[Adapter Implementation<br/>Adapter Implementation]\n    D[Domain Service<br/>Domain Service] --> B\n    \n    style A fill:#e1f5fe\n    style D fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#fff3e0\n```\n\n### Implementation Patterns\n\n#### Application Service Using Ports\n\n```java\n@Service\n@Transactional\npublic class CustomerApplicationService implements CustomerUseCase {\n    \n    private final CustomerRepository customerRepository;\n    private final EmailService emailService;\n    private final EventPublisher eventPublisher;\n    private final CustomerValidationService validationService;\n    \n    public CustomerApplicationService(\n            CustomerRepository customerRepository,\n            EmailService emailService,\n            EventPublisher eventPublisher,\n            CustomerValidationService validationService) {\n        this.customerRepository = customerRepository;\n        this.emailService = emailService;\n        this.eventPublisher = eventPublisher;\n        this.validationService = validationService;\n    }\n    \n    @Override\n    public CustomerResponse createCustomer(CreateCustomerCommand command) {\n        // 1. Validate business rules\n        if (!validationService.isEmailUnique(command.email())) {\n            throw new EmailAlreadyExistsException(command.email());\n        }\n        \n        // 2. Create aggregate root\n        Customer customer = new Customer(\n            CustomerId.generate(),\n            command.name(),\n            command.email(),\n            command.phone()\n        );\n        \n        // 3. Save aggregate root\n        customerRepository.save(customer);\n        \n        // 4. Publish domain events\n        List<DomainEvent> events = customer.getUncommittedEvents();\n        eventPublisher.publishAll(events);\n        customer.markEventsAsCommitted();\n        \n        // 5. Send welcome email\n        emailService.sendWelcomeEmail(customer.getEmail(), customer.getName());\n        \n        return CustomerResponse.from(customer);\n    }\n    \n    @Override\n    public CustomerResponse updateCustomer(UpdateCustomerCommand command) {\n        // 1. Load aggregate root\n        Customer customer = customerRepository.findById(command.customerId())\n            .orElseThrow(() -> new CustomerNotFoundException(command.customerId()));\n        \n        // 2. Execute business operation\n        customer.updateProfile(command.name(), command.email(), command.phone());\n        \n        // 3. Save changes\n        customerRepository.save(customer);\n        \n        // 4. Publish events\n        List<DomainEvent> events = customer.getUncommittedEvents();\n        eventPublisher.publishAll(events);\n        customer.markEventsAsCommitted();\n        \n        return CustomerResponse.from(customer);\n    }\n    \n    @Override\n    public CustomerResponse getCustomer(GetCustomerQuery query) {\n        Customer customer = customerRepository.findById(query.customerId())\n            .orElseThrow(() -> new CustomerNotFoundException(query.customerId()));\n        \n        return CustomerResponse.from(customer);\n    }\n}\n```\n\n### Dependency Injection Configuration\n\n```java\n@Configuration\npublic class ApplicationConfiguration {\n    \n    // Application service configuration\n    @Bean\n    public CustomerUseCase customerUseCase(\n            CustomerRepository customerRepository,\n            EmailService emailService,\n            EventPublisher eventPublisher,\n            CustomerValidationService validationService) {\n        return new CustomerApplicationService(\n            customerRepository,\n            emailService,\n            eventPublisher,\n            validationService\n        );\n    }\n    \n    // Domain service configuration\n    @Bean\n    public CustomerValidationService customerValidationService(\n            CustomerRepository customerRepository) {\n        return new CustomerValidationService(customerRepository);\n    }\n}\n\n@Configuration\npublic class InfrastructureConfiguration {\n    \n    // Repository adapter\n    @Bean\n    public CustomerRepository customerRepository(\n            CustomerJpaRepository jpaRepository,\n            CustomerMapper customerMapper) {\n        return new CustomerRepositoryAdapter(jpaRepository, customerMapper);\n    }\n    \n    // External service adapter\n    @Bean\n    public EmailService emailService(\n            ExternalEmailClient emailClient,\n            EmailTemplateService templateService) {\n        return new EmailServiceAdapter(emailClient, templateService);\n    }\n    \n    // Event publisher adapter\n    @Bean\n    public EventPublisher eventPublisher(ApplicationEventPublisher springEventPublisher) {\n        return new SpringEventPublisherAdapter(springEventPublisher);\n    }\n}\n```\n\n## ðŸ“š Layered Design\n\n### Layered Architecture\n\nHexagonal architecture can be viewed as a special type of layered architecture, but the focus is on ports and adapters rather than traditional horizontal layers.\n\n#### Traditional Layers vs Hexagonal Architecture\n\n```text\nTraditional Layered Architecture:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   Presentation  â”‚ â† Presentation layer\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚    Business     â”‚ â† Business layer\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   Persistence   â”‚ â† Persistence layer\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nHexagonal Architecture:\n        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n    â”Œâ”€â”€â”€â”‚   Adapters  â”‚â”€â”€â”€â”\n    â”‚   â”‚  (Infrastructure) â”‚\n    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ”Œâ”€â”€â”€â–¼â”€â”€â”€â”           â”Œâ”€â”€â”€â–¼â”€â”€â”€â”\nâ”‚ Ports â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Ports â”‚\nâ””â”€â”€â”€â”¬â”€â”€â”€â”˜           â””â”€â”€â”€â”¬â”€â”€â”€â”˜\n    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\n    â””â”€â”€â”€â”‚ Application â”‚â”€â”€â”€â”˜\n        â”‚   & Domain  â”‚\n        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Layer Responsibilities\n\n#### Domain Layer\n\n```java\n// Aggregate root\n@AggregateRoot(name = \"Customer\", boundedContext = \"Customer\")\npublic class Customer implements AggregateRootInterface {\n    // Pure business logic, no dependencies on external technologies\n    \n    public void updateProfile(CustomerName name, Email email, Phone phone) {\n        validateProfileUpdate(name, email, phone);\n        \n        this.name = name;\n        this.email = email;\n        this.phone = phone;\n        \n        collectEvent(CustomerProfileUpdatedEvent.create(this.id, name, email, phone));\n    }\n    \n    private void validateProfileUpdate(CustomerName name, Email email, Phone phone) {\n        if (name == null || email == null || phone == null) {\n            throw new InvalidProfileDataException(\"All fields are required\");\n        }\n    }\n}\n\n// Domain service\n@DomainService(name = \"CustomerValidationService\", boundedContext = \"Customer\")\n@Component\npublic class CustomerValidationService {\n    \n    private final CustomerRepository customerRepository;\n    \n    public CustomerValidationService(CustomerRepository customerRepository) {\n        this.customerRepository = customerRepository;\n    }\n    \n    public boolean isEmailUnique(Email email) {\n        return customerRepository.findByEmail(email).isEmpty();\n    }\n    \n    public boolean isEmailUnique(Email email, CustomerId excludeCustomerId) {\n        return customerRepository.findByEmail(email)\n            .map(Customer::getId)\n            .filter(id -> !id.equals(excludeCustomerId))\n            .isEmpty();\n    }\n}\n```\n\n#### Application Layer\n\n```java\n// Application service - coordinates domain objects and infrastructure\n@Service\n@Transactional\npublic class CustomerApplicationService implements CustomerUseCase {\n    \n    // Depends on port abstractions, not concrete implementations\n    private final CustomerRepository customerRepository;\n    private final EmailService emailService;\n    private final EventPublisher eventPublisher;\n    \n    // Use case implementation - coordinates multiple domain objects\n    @Override\n    public CustomerResponse createCustomer(CreateCustomerCommand command) {\n        // 1. Business validation\n        validateCreateCustomerCommand(command);\n        \n        // 2. Create domain object\n        Customer customer = Customer.create(command.name(), command.email(), command.phone());\n        \n        // 3. Persistence\n        customerRepository.save(customer);\n        \n        // 4. Publish events\n        publishDomainEvents(customer);\n        \n        // 5. Trigger side effects\n        emailService.sendWelcomeEmail(customer.getEmail(), customer.getName());\n        \n        return CustomerResponse.from(customer);\n    }\n    \n    private void validateCreateCustomerCommand(CreateCustomerCommand command) {\n        if (!validationService.isEmailUnique(command.email())) {\n            throw new EmailAlreadyExistsException(command.email());\n        }\n    }\n    \n    private void publishDomainEvents(Customer customer) {\n        List<DomainEvent> events = customer.getUncommittedEvents();\n        eventPublisher.publishAll(events);\n        customer.markEventsAsCommitted();\n    }\n}\n```\n\n#### Infrastructure Layer\n\n```java\n// Adapter implementation - connects external technologies\n@Repository\npublic class CustomerRepositoryAdapter implements CustomerRepository {\n    \n    private final CustomerJpaRepository jpaRepository;\n    private final CustomerMapper mapper;\n    \n    @Override\n    public void save(Customer customer) {\n        CustomerEntity entity = mapper.toEntity(customer);\n        jpaRepository.save(entity);\n    }\n    \n    @Override\n    public Optional<Customer> findById(CustomerId customerId) {\n        return jpaRepository.findById(customerId.getValue())\n            .map(mapper::toDomain);\n    }\n}\n\n// JPA entity - technical concerns\n@Entity\n@Table(name = \"customers\")\npublic class CustomerEntity {\n    \n    @Id\n    private String id;\n    \n    @Column(name = \"name\", nullable = false)\n    private String name;\n    \n    @Column(name = \"email\", nullable = false, unique = true)\n    private String email;\n    \n    @Column(name = \"phone\")\n    private String phone;\n    \n    @Enumerated(EnumType.STRING)\n    @Column(name = \"status\")\n    private CustomerStatus status;\n    \n    @CreationTimestamp\n    @Column(name = \"created_at\")\n    private LocalDateTime createdAt;\n    \n    @UpdateTimestamp\n    @Column(name = \"updated_at\")\n    private LocalDateTime updatedAt;\n    \n    // Constructors, getters, setters\n}\n```\n\n### Inter-Layer Communication Rules\n\n1. **Domain Layer**: Does not depend on any other layers\n2. **Application Layer**: Depends on domain layer, communicates with infrastructure layer through ports\n3. **Infrastructure Layer**: Depends on application and domain layers, implements port contracts\n\n## Testing Strategy\n\n### Unit Testing\n\n```java\n@ExtendWith(MockitoExtension.class)\nclass CustomerApplicationServiceTest {\n    \n    @Mock\n    private CustomerRepository customerRepository;\n    \n    @Mock\n    private EmailService emailService;\n    \n    @Mock\n    private EventPublisher eventPublisher;\n    \n    @Mock\n    private CustomerValidationService validationService;\n    \n    @InjectMocks\n    private CustomerApplicationService customerApplicationService;\n    \n    @Test\n    void should_create_customer_successfully() {\n        // Given\n        CreateCustomerCommand command = new CreateCustomerCommand(\n            new CustomerName(\"John Doe\"),\n            new Email(\"john@example.com\"),\n            new Phone(\"0912345678\")\n        );\n        \n        when(validationService.isEmailUnique(command.email())).thenReturn(true);\n        \n        // When\n        CustomerResponse response = customerApplicationService.createCustomer(command);\n        \n        // Then\n        assertThat(response.name()).isEqualTo(\"John Doe\");\n        assertThat(response.email()).isEqualTo(\"john@example.com\");\n        \n        verify(customerRepository).save(any(Customer.class));\n        verify(emailService).sendWelcomeEmail(command.email(), command.name());\n        verify(eventPublisher).publishAll(anyList());\n    }\n}\n```\n\n### Integration Testing\n\n```java\n@SpringBootTest\n@Transactional\nclass CustomerApplicationServiceIntegrationTest {\n    \n    @Autowired\n    private CustomerUseCase customerUseCase;\n    \n    @Autowired\n    private CustomerRepository customerRepository;\n    \n    @MockBean\n    private EmailService emailService;\n    \n    @Test\n    void should_integrate_with_real_database() {\n        // Given\n        CreateCustomerCommand command = new CreateCustomerCommand(\n            new CustomerName(\"Integration Test\"),\n            new Email(\"integration@test.com\"),\n            new Phone(\"0987654321\")\n        );\n        \n        // When\n        CustomerResponse response = customerUseCase.createCustomer(command);\n        \n        // Then\n        assertThat(response.id()).isNotNull();\n        \n        // Verify database state\n        Optional<Customer> savedCustomer = customerRepository.findById(\n            CustomerId.of(response.id())\n        );\n        assertThat(savedCustomer).isPresent();\n        assertThat(savedCustomer.get().getName().getValue()).isEqualTo(\"Integration Test\");\n    }\n}\n```\n\n### Architecture Testing\n\n```java\n@ArchTest\nstatic final ArchRule domain_should_not_depend_on_infrastructure =\n    noClasses()\n        .that().resideInAPackage(\"..domain..\")\n        .should().dependOnClassesThat()\n        .resideInAPackage(\"..infrastructure..\");\n\n@ArchTest\nstatic final ArchRule application_should_only_depend_on_domain_and_ports =\n    classes()\n        .that().resideInAPackage(\"..application..\")\n        .should().onlyDependOnClassesThat()\n        .resideInAnyPackage(\"..domain..\", \"..application..\", \"java..\", \"org.springframework..\");\n\n@ArchTest\nstatic final ArchRule ports_should_be_interfaces =\n    classes()\n        .that().resideInAPackage(\"..application..port..\")\n        .should().beInterfaces()\n        .because(\"Ports should be interfaces defining abstract contracts\");\n\n@ArchTest\nstatic final ArchRule adapters_should_implement_ports =\n    classes()\n        .that().resideInAPackage(\"..infrastructure..adapter..\")\n        .and().areNotInterfaces()\n        .should().implement(JavaClass.Predicates.resideInAPackage(\"..application..port..\"))\n        .because(\"Adapters should implement port interfaces\");\n```\n\n## Best Practices\n\n### 1. Port Design\n\n- **Use Domain Language**: Port method names should reflect business intent\n- **Avoid Technical Leakage**: Ports should not expose technical implementation details\n- **Maintain Stability**: Port interfaces should be relatively stable, avoiding frequent changes\n- **Single Responsibility**: Each port should have a clear scope of responsibility\n\n### 2. Adapter Implementation\n\n- **Protocol Translation**: Adapters are responsible for translating between internal and external protocols\n- **Error Handling**: Adapters should handle external system exceptions and convert them to domain exceptions\n- **Technical Isolation**: Encapsulate technical details within adapters\n- **Replaceability**: Adapters should be easily replaceable without affecting core logic\n\n### 3. Dependency Management\n\n- **Constructor Injection**: Prefer constructor injection to ensure dependency immutability\n- **Interface Injection**: Inject interfaces rather than concrete implementations\n- **Configuration Separation**: Separate dependency configuration from business logic\n- **Avoid Circular Dependencies**: Design to avoid circular dependencies\n\n### 4. Testing Strategy\n\n- **Mock External Dependencies**: Mock all external dependencies in unit tests\n- **Integration Testing**: Verify adapter integration with external systems\n- **Architecture Testing**: Use ArchUnit to ensure correct dependency directions\n- **End-to-End Testing**: Verify complete business processes\n\nThrough hexagonal architecture, we achieve:\n\n- Complete separation of business logic from technical implementation\n- High testability and maintainability\n- Flexible technology choices and replacement capabilities\n- Clear architectural boundaries and responsibility division\n\n---\n\n**Related Documents**\n- [DDD Domain-Driven Design](ddd-domain-driven-design.md)\n- Microservices Architecture\n- Saga Patterns"