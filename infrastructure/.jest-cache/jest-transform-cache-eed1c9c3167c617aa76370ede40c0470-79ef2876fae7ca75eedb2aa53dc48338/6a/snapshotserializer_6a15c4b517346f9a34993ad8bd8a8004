aa8a89b53b13409c3e880dc7e9557588
/**
 * Custom snapshot serializer for CDK templates
 * Provides better snapshot formatting and drift detection
 */

const crypto = require('crypto');

// Custom serializer for CDK CloudFormation templates
const cdkTemplateSerializer = {
    test(val) {
        return val && typeof val === 'object' &&
            (val.AWSTemplateFormatVersion || val.Resources || val.Outputs);
    },

    serialize(val, config, indentation, depth, refs, printer) {
        // Sort resources by type and logical ID for consistent snapshots
        const sortedTemplate = { ...val };

        if (sortedTemplate.Resources) {
            const sortedResources = {};
            Object.keys(sortedTemplate.Resources)
                .sort((a, b) => {
                    const typeA = sortedTemplate.Resources[a].Type;
                    const typeB = sortedTemplate.Resources[b].Type;
                    if (typeA !== typeB) return typeA.localeCompare(typeB);
                    return a.localeCompare(b);
                })
                .forEach(key => {
                    sortedResources[key] = sortedTemplate.Resources[key];
                });
            sortedTemplate.Resources = sortedResources;
        }

        // Sort outputs for consistency
        if (sortedTemplate.Outputs) {
            const sortedOutputs = {};
            Object.keys(sortedTemplate.Outputs)
                .sort()
                .forEach(key => {
                    sortedOutputs[key] = sortedTemplate.Outputs[key];
                });
            sortedTemplate.Outputs = sortedOutputs;
        }

        // Remove CDK metadata that changes frequently
        if (sortedTemplate.Metadata) {
            delete sortedTemplate.Metadata['AWS::CDK::Path'];
        }

        // Generate a hash for the template to detect changes
        const templateHash = crypto
            .createHash('sha256')
            .update(JSON.stringify(sortedTemplate))
            .digest('hex')
            .substring(0, 8);

        // Add template metadata for drift detection
        const templateWithMetadata = {
            ...sortedTemplate,
            '__CDK_SNAPSHOT_METADATA__': {
                hash: templateHash,
                timestamp: new Date().toISOString(),
                resourceCount: Object.keys(sortedTemplate.Resources || {}).length,
                outputCount: Object.keys(sortedTemplate.Outputs || {}).length
            }
        };

        return printer(templateWithMetadata, config, indentation, depth, refs);
    }
};

// Custom serializer for test validation reports
const validationReportSerializer = {
    test(val) {
        return val && typeof val === 'object' &&
            val.hasOwnProperty('overall') &&
            val.hasOwnProperty('categories') &&
            val.hasOwnProperty('issues');
    },

    serialize(val, config, indentation, depth, refs, printer) {
        // Sort issues by severity and category for consistent snapshots
        const sortedReport = { ...val };

        if (sortedReport.issues) {
            sortedReport.issues = sortedReport.issues.sort((a, b) => {
                const severityOrder = { 'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3 };
                const severityDiff = (severityOrder[a.severity] || 4) - (severityOrder[b.severity] || 4);
                if (severityDiff !== 0) return severityDiff;
                return a.category.localeCompare(b.category);
            });
        }

        return printer(sortedReport, config, indentation, depth, refs);
    }
};

module.exports = [cdkTemplateSerializer, validationReportSerializer];